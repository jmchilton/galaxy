<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    elementFormDefault="qualified"
    attributeFormDefault="unqualified"
    >
  <xs:annotation>
    <xs:appinfo>Galaxy Schema</xs:appinfo>
    <xs:documentation xml:lang="en">A Galaxy XML tool wrapper</xs:documentation>
  </xs:annotation>

  <xs:element name="tool">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
The outer-most tag set of tool XML files. Attributes on this tag apply to the
tool as a whole.

### Examples

A normal tool:

```xml
<tool id="seqtk_seq"
      name="Convert FASTQ to FASTA"
      version="1.0.0"
      profile="16.04"
>
```

A ``data_source`` tool contains a few more relevant attributes.

```xml
<tool id="ucsc_table_direct1"
      name="UCSC Main"
      version="1.0.0"
      hidden="false"
      profile="16.01"
      tool_type="data_source"
      URL_method="post">
```
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:all>
        <!-- TODO: Move the anyType further into macros def... -->
        <xs:element name="macros" type="xs:anyType" minOccurs="0"/>
        <xs:element name="requirements" type="Requirements" minOccurs="0"/>
        <xs:element name="description" type="xs:string" minOccurs="0">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[The value is displayed in
the tool menu immediately following the hyperlink for the tool (based on the
``name`` attribute of the ``<tool>`` tag set described above).

### Example

```xml
<description>table browser</description>
```
]]></xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="parallelism" type="Parallelism" minOccurs="0"/>
        <xs:element name="version_command" type="xs:string" minOccurs="0">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[Specifies the command to be run in
order to get the tool's version string. The resulting value will be found in the
"Info" field of the history dataset.

Unlike the [``command``](#tool|command) tag, this value is taken as a literal and so there is no
need to escape values like ``$`` and command inputs are not available for variable
substitution.

### Example

```xml
<version_command>tophat -version</version_command>
```
]]></xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="action" type="ToolAction" minOccurs="0" maxOccurs="1" />
        <xs:element name="environment_variables" type="EnvironmentVariables" minOccurs="0" maxOccurs="1"/>
        <xs:element name="command" type="Command"/>
        <xs:element name="request_parameter_translation" type="RequestParameterTranslation" minOccurs="0"/>
        <xs:element name="configfiles" type="ConfigFiles" minOccurs="0"/>
        <xs:element name="outputs" type="Outputs" minOccurs="0"/>
        <xs:element name="inputs" type="Inputs" minOccurs="0"/>
        <xs:element name="tests" type="Tests" minOccurs="0"/>
        <xs:element name="stdio" type="Stdio" minOccurs="0"/>
        <xs:element name="help" type="xs:string" minOccurs="0">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[This tag set includes all of the necessary details of how to use the tool. This tag set should be included as the last tag set in the tool config. Tool help is written in reStructuredText. Included here is only an overview of a subset of features. For more information see http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html.

| tag | details |
| ``.. class:: warningmark`` | a yellow warning symbol  |
| ``.. class:: infomark`` | a blue information symbol |
| ``.. image:: path-of-the-file.png :height: 500 :width: 600`` | insert a png file of height 500 and width 600 at this position |
| ``**bold**`` | bold |
| ``*italic*`` | italic |
| ``*`` | list |
| ``-`` |list |
| ``::`` | paragraph|
| ``-----`` | a horizontal line |

Example:

Show a warning sign to remind users that this tool accept fasta format files only, followed by an example of the query sequence and a figure.

```xml
<help>

.. class:: warningmark

'''TIP''' This tool requires *fasta* format.

----

'''Example'''

Query sequence::
    >seq1
    >ATCG...

.. image:: my_figure.png
    :height: 500
    :width: 600

</help>
```

Best Practices

From https://galaxy-iuc-standards.readthedocs.org/en/latest/ :

The help tag should be started and finished by a [CDATA tag](https://en.wikipedia.org/wiki/CDATA).
</help>
]]></xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="code" type="Code" minOccurs="0"/>
        <xs:element name="uihints" type="UIhints" minOccurs="0"/>
        <xs:element name="options" type="Options" minOccurs="0"/>
        <xs:element name="trackster_conf" type="TracksterConf" minOccurs="0"/>
        <xs:element name="citations" type="Citations" minOccurs="0"/>
      </xs:all>
      <xs:attribute name="id" type="xs:string" use="required">
        <xs:annotation>
          <xs:documentation xml:lang="en">Must be unique across all tools;
should be lowercase and contain only letters, numbers, and underscores.
It allows for tool versioning and metrics of the number of times a tool is used,
among other things.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string" use="required">
        <xs:annotation>
          <xs:documentation xml:lang="en">This string is what is displayed as a
hyperlink in the tool menu.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="version" type="xs:string" default="1.0.0">
        <xs:annotation>
          <xs:documentation xml:lang="en">This string defaults to ``1.0.0`` if it is not
included in the tag. It allows for tool versioning and should be changed with each new version
of the tool.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="hidden" type="PermissiveBoolean" default="false">
        <xs:annotation>
          <xs:documentation xml:lang="en">Allows for tools to be loaded upon
server startup, but not displayed in the tool menu. This attribute should be
applied in the toolbox configuration instead and so should be considered
deprecated.
</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="display_interface" type="PermissiveBoolean">
        <xs:annotation>
          <xs:documentation xml:lang="en">Disable the display the tool's
graphical tool form by setting this to ``false``.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="tool_type" type="ToolTypeType">
        <xs:annotation>
          <xs:documentation xml:lang="en">Allows for certain framework
functionality to be performed on certain types of tools. Normal tools that execute
typical command-line jobs do not need to specify this, special kinds of tools such
as [Data Source](https://wiki.galaxyproject.org/Admin/Internals/DataSources) and
[Data Manager](https://wiki.galaxyproject.org/Admin/Tools/DataManagers) tools should
set this to have values such as ``data_source`` or ``manage_data``.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="profile" type="xs:string">
        <xs:annotation>
          <xs:documentation xml:lang="en">This string specified the minimum Galaxy
version that should be required to run this tool. Certain legacy behaviors such
as using standard error content to detect errors instead of exit code are disabled
automatically if profile is set to any version newer than ``16.01``, such as
``16.04``.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="workflow_compatible" type="xs:boolean" default="true">
        <xs:annotation>
          <xs:documentation xml:lang="en">This attribute indicates if
this tool usable within a workflow (defaults to ``true`` for normal tools and
``false`` for data sources).</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="URL_method" type="URLmethodType">
        <xs:annotation>
          <xs:documentation xml:lang="en">Only used if ``tool_type`` attribute value
is ``data_source`` - this attribute defines the HTTP request method to use when
communicating with an external data source application (the default is ``get``).</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:complexType name="ToolAction">
    <xs:annotation>
      <xs:documentation xml:lang="en">Describe the backend Python action to execute for this Galaxy tool.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="module" type="xs:string" use="required">
    </xs:attribute>
    <xs:attribute name="class" type="xs:string" use="required">
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Requirements">
    <xs:annotation>
      <xs:documentation xml:lang="en">This is a container tag set for the 'requirement' tag set described below. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="requirement" type="Requirement" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="container" type="Container" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="Requirement">
    <xs:annotation>
      <xs:documentation xml:lang="en">This tag set is contained within the 'requirements' tag set. Third party programs or modules that the tool depends upon (and which are not distributed with Galaxy) are included in this tag set. The intention is that when Galaxy starts it can check whether the required programs or modules are available, and if not this tool will not be loaded. </xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="type" type="RequirementType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"> This value defines the which type of the 3rd party module required by this tool </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="version" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"> Required for package type requirements </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="Container">
    <xs:annotation>
      <xs:documentation xml:lang="en">This tag set is contained within the 'requirements' tag set. Galaxy can be configured to run tools within Docker (https://www.docker.com/) containers - this tag allows the tool to suggest possible valid Docker containers for this tool.
      </xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="type" type="ContainerType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"> This value describes the type of container that the tool may be executed in and currently must be 'docker'. </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="Parallelism">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for Parallelism</xs:documentation>
    </xs:annotation>
    <xs:attribute name="method" type="MethodType">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for method</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="merge_outputs" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for merge_outputs</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="split_inputs" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for split_inputs</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="split_size" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for split_size</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="split_mode" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for split_mode</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Code">
    <xs:annotation>
      <xs:documentation xml:lang="en">**Deprecated** do not use this unless absolutely necessary. This tag set provides detailed control of the way the tool is executed. This (optional) code can be deployed in a separate file in the same directory as the tool's config file. These hooks are being replaced by new tool config features and methods in the ~/lib/galaxy/tools/__init__.py code file.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="file" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value is the name of the executable code file, and is called in the exec_before_process(), exec_before_job(), exec_after_process() and exec_after_job()( methods.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="UIhints">
    <xs:annotation>
      <xs:documentation xml:lang="en">Used only for data source tools, this directive contains UI options (currently only ``minwidth`` is valid).</xs:documentation>
    </xs:annotation>
    <xs:attribute name="minwidth" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for minwidth</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Options">
    <xs:annotation>
      <xs:documentation xml:lang="en">This directive is used to specify some rarely modified options.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="refresh" type="PermissiveBoolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">Deprecated, likely unused attribute.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sanitize" type="PermissiveBoolean" default="true">
      <xs:annotation>
        <xs:documentation xml:lang="en">This attribute can be used to turn off all input sanitization for a tool.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="TracksterConf">
    <xs:annotation>
      <xs:documentation xml:lang="en">This directive is used to specify some rarely modified trackster options.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="action" type="TracksterAction" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="TracksterAction">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="output_name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Tests">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Container tag set for the <test> tag sets. Any number of tests can be included, and each test is wrapped within separate <test> tag sets. Functional tests are executed via Planemo or the ~/run_tests.sh shell script.

See [WritingTests](https://wiki.galaxyproject.org/Admin/Tools/WritingTests) on the wiki and [Test-Driven Development](http://planemo.readthedocs.io/en/latest/writing_advanced.html#test-driven-development) section of the Planemo docs for more information on writing tests.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="test" type="Test" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="Test">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[This tag set contains the necessary parameter values for executing the tool via the functional test framework.

Example

The following two tests will tool execute the ~/tools/filters/sorter.xml tool. Notice the way that the tool's inputs and outputs are defined.


Toggle line numbers
  <tests>
    <test>
      <param name="input" value="1.bed"/>
      <param name="column" value="1"/>
      <param name="order" value="ASC"/>
      <param name="style" value="num"/>
      <output name="out_file1" file="sort1_num.bed"/>
    </test>
    <test>
      <param name="input" value="7.bed"/>
      <param name="column" value="1"/>
      <param name="order" value="ASC"/>
      <param name="style" value="alpha"/>
      <output name="out_file1" file="sort1_alpha.bed"/>
    </test>
  </tests>
Example

Test the execution of the MAF-to-FASTA converter ( ~/tools/maf/maf_to_fasta.xml ).


Toggle line numbers
<tests>
    <test>
        <param name="input1" value="3.maf" ftype="maf"/>
        <param name="species" value="canFam1"/>
        <param name="fasta_type" value="concatenated"/>
        <output name="out_file1" file="cf_maf2fasta_concat.dat" ftype="fasta"/>
    </test>
</tests>
Example

This test demonstrates verifying specific properties about a test output instead of directly comparing it to another file. Here the file attribute is not specified and instead a series of assertions is made about the output.


Toggle line numbers
<test>
    <param name="input" value="maf_stats_interval_in.dat" />
    <param name="lineNum" value="99999"/>
    <output name="out_file1">
        <assert_contents>
            <has_text text="chr7" />
            <not_has_text text="chr8" />
            <has_text_matching expression="1274\d+53" />
            <has_line_matching expression=".*\s+127489808\s+127494553" />
            <!-- &#009; is XML escape code for tab -->
            <has_line line="chr7&#009;127471195&#009;127489808" />
            <has_n_columns n="3" />
        </assert_contents>
    </output>
</test>
]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="TestParamElement" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="output" type="TestOutput" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="output_collection" type="TestOutputCollection" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="assert_command" type="TestAssertions" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation xml:lang="en">Describe assertions about the jobs standard error.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="assert_stdout" type="TestAssertions" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation xml:lang="en">Describe assertions about the jobs standard error.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="assert_stderr" type="TestAssertions" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation xml:lang="en">Describe assertions about the jobs standard error.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="expect_exit_code" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Describe the job's expected exit code.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expect_num_outputs" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Assert the number of outputs this test should produce.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expect_failure" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation xml:lang="en">Expect the job to fail, if set to true no job output checks may be present in test definition.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxseconds" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Maximum amount of time to let test run.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="TestParamElement">
    <xs:choice>
      <xs:element name="param" type="TestParam" />
      <xs:element name="repeat" type="TestRepeat" />
      <xs:element name="conditional" type="TestConditional" />
      <xs:element name="section" type="TestSection" />
      <xs:element name="output" type="TestOutput" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="output_collection" type="TestOutputCollection"/>
      <xs:element name="assert_command" type="TestAssertions">
        <xs:annotation>
          <xs:documentation xml:lang="en">Describe assertions about the jobs standard error.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="assert_stdout" type="TestAssertions">
        <xs:annotation>
          <xs:documentation xml:lang="en">Describe assertions about the jobs standard error.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="assert_stderr" type="TestAssertions">
        <xs:annotation>
          <xs:documentation xml:lang="en">Describe assertions about the jobs standard error.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="TestSection">
    <xs:sequence>
      <xs:group ref="TestParamElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestConditional">
    <xs:sequence>
      <xs:group ref="TestParamElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestRepeat">
    <xs:sequence>
      <xs:group ref="TestParamElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required" />
  </xs:complexType>
  <xs:complexType name="TestParam">
    <xs:annotation>
      <xs:documentation xml:lang="en">This tag set defines the tool's input parameters for executing the tool via the functional test framework.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="collection" type="TestCollection" minOccurs="0" maxOccurs="1" />
      <xs:element name="composite_data" type="TestCompositeData" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="metadata" type="TestParamMetadata" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must match the name of the associated input parameter.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must be one of the legal values that can be assigned to an input parameter.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftype" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This attribute name should be included only with the parameter that defines the input dataset for the tool. If this attribute name is not included, the functional test framework will attempt to determine the data type for the input dataset using the data type sniffers.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dbkey" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">dbkey for the referenced input format.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestCompositeData">
    <xs:annotation>
      <xs:documentation xml:lang="en">Define extra composite input files for test input.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Path relative to test-data of composite file.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftype" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Optional datatype of composite file for test input.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestCollection">
    <xs:annotation>
      <xs:documentation xml:lang="en">Definition of a collection for test input.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="element" type="TestParam" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="type" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Type of collection to create.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestOutput">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for TestOutput</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="TestOutputElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <!-- TODO: This would be more percise if this was required if at the top-level. -->
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="file" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftype" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for ftype</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sort" type="PermissiveBoolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for sort</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">An alias for file.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="md5" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Expected MD5sum for output.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checksum" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Checksum expression for output in the form ``hash_type:hash_value`` (e.g. ``sha1$8156d7ca0f46ed7abac98f82e36cfaddb2aca041``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compare" type="TestOutputCompareType">
    </xs:attribute>
    <xs:attribute name="lines_diff" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">If ``compare`` is set to ``diff``, the number of lines of difference to allow (each line with a modification is a line added and a line removed so this counts as two lines).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delta" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">If ``compare`` is set to ``sim_size``, this is the number of bytes different allowed.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="TestOutputElement">
    <xs:choice>
      <xs:element name="element" type="TestOutput"/>
      <!-- TODO: This would be more percise if this was only allowed at the top-level. -->
      <xs:element name="discovered_dataset" type="TestDiscoveredDataset"/>
      <!-- TODO: To be more percise only one assert_contents is allowed - this should not be in here. -->
      <xs:element name="assert_contents" type="TestAssertions"/>
      <!-- TODO: This would be more percise if this was only allowed at the top-level. -->
      <xs:element name="extra_files" type="TestExtraFile" />
      <xs:element name="metadata" type="TestOutputMetadata"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="TestParamMetadata">
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestOutputMetadata">
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestDiscoveredDataset">
    <xs:annotation>
      <xs:documentation xml:lang="en">Define test for a discovered dataset on corresponding output.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="TestOutput">
        <xs:attribute type="xs:string" name="designation">
          <xs:annotation>
            <xs:documentation xml:lang="en">The designation of the discovered dataset.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TestExtraFile">
    <xs:annotation>
      <xs:documentation xml:lang="en">Define test for extra files on corresponding output.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="TestOutput">
        <xs:attribute type="xs:string" name="type">
          <xs:annotation>
            <xs:documentation xml:lang="en">Extra file type (either ``file`` or ``directory``).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TestOutputCollection">
    <xs:annotation>
      <xs:documentation xml:lang="en">Define test for extra files on corresponding output collection.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="element" type="TestOutput" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="count" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Number of elements in output collection.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestAssertions">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for TestAssertion</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="TestAssertion" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="TestAssertion">
    <xs:choice>
      <xs:element name="has_text" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the specified ``text`` appears in the output (e.g. ``<has_text text="chr7">``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="not_has_text" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the specified ``text`` does not appear in the output (e.g. ``<not_has_text text="chr8" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has_text_matching" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts text matching the specified regular expression (``expression``) appears in the output (e.g. ``<has_text_matching expression="1274\d+53" />`` ).]]>
        </xs:documentation>
      </xs:annotation>
      </xs:element>
      <xs:element name="has_line" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts a line matching the specified string (``line``) appears in the output (e.g. ``<has_line line="A full example line." />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has_line_matching" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts a line matching the specified regular expression (``expression``) appears in the output (e.g. ``<has_line_matching expression=".*\s+127489808\s+127494553" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has_n_columns" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts tabular output contains the specified number (``n``) of columns (e.g. ``<has_n_columns n="3" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="is_valid_xml" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the output is a valid XML file (e.g. ``<is_valid_xml />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has_element_with_path" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the XML output contains at least one element (or tag) with the specified XPath-like ``path`` (e.g. ``<has_element_with_path path="BlastOutput_param/Parameters/Parameters_matrix" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has_n_elements_with_path" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the XML output contains the specified number (``n``) of elements (or tags) with the specified XPath-like ``path`` (e.g. ``<has_n_elements_with_path n="9" path="BlastOutput_iterations/Iteration/Iteration_hits/Hit/Hit_num" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="element_text_is" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the text of the XML element with the specified XPath-like ``path`` is the specified ``text`` (e.g. ``<element_text_is path="BlastOutput_program" text="blastp" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="element_text_matches">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the text of the XML element with the specified XPath-like ``path`` matches the regular expression defined by ``expression`` (e.g. ``<element_text_matches path="BlastOutput_version" expression="BLASTP\s+2\.2.*" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="attribute_is" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the XML ``attribute`` for the element (or tag) with the specified XPath-like ``path`` is the specified ``text`` (e.g. ``<attribute_is path="outerElement/innerElement1" attribute="foo" text="bar" />`` ).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="attribute_matches" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the XML ``attribute`` for the element (or tag) with the specified XPath-like ``path`` matches the regular expression specified by ``expression`` || ``<attribute_matches path="outerElement/innerElement2" attribute="foo2" expression="bar\d+" />``).]]></xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="element_text" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[This tag allows the developer to recurisively specify additional assertions as child elements about just the text contained in the element specified by the XPath-like ``path`` (e.g. ``<element_text path="BlastOutput_iterations/Iteration/Iteration_hits/Hit/Hit_def"><not_has_text text="EDK72998.1" /></element_text>`` ||).]]></xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Inputs">
    <xs:annotation>
      <xs:documentation xml:lang="en">Consists of all tag sets that define the tool's input parameters. Each &lt;param&gt; tag within the &lt;inputs&gt; tag set maps to a command line parameter within the 'command' tag set described above.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="InputElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="action" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for action</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="check_values" type="PermissiveBoolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for check_values</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="method" type="URLmethodType">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for method</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="target" type="TargetType">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for target</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="nginx_upload" type="xs:boolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">Boolean indicates if this is an upload tool or not.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>


  <xs:group name="InputElement">
    <xs:choice>
      <xs:element name="param" type="Param"/>
      <xs:element name="repeat" type="Repeat"/>
      <xs:element name="conditional" type="Conditional"/>
      <xs:element name="section" type="Section"/>
      <xs:element name="upload_dataset" type="xs:anyType">
        <xs:annotation>
          <xs:documentation xml:lang="en">Internal, intentionally undocumented feature.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="display" type="xs:string">
        <xs:annotation>
          <xs:documentation xml:lang="en">Documentation for display</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="InputType" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for InputType</xs:documentation>
    </xs:annotation>
    <xs:sequence/>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Name for this element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>


  <xs:complexType name="Conditional">
    <xs:annotation>
      <xs:documentation xml:lang="en">This is a container for conditional parameters in the tool ( must contain 'when' tag sets ) - the command line is wrapped in an if-else statement. </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="InputType">
        <xs:sequence>
          <xs:group ref="InputElement" minOccurs="0" maxOccurs="1" />
          <xs:element name="when" type="ConditionalWhen" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="value_from" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[Infrequently used option to dynamically access Galaxy internals, this should be avoided.

Galaxy method to execute.]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="value_ref" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[Infrequently used option to dynamically access Galaxy internals, this should be avoided.

Referenced parameter to pass method.]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="value_ref_in_group" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation><![CDATA[Infrequently used option to dynamically access Galaxy internals, this should be avoided.

Is referenced parameter is the same group.]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>

        <xs:attribute name="label" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Human readable description for the conditional, unused in the Galaxy UI currently.</xs:documentation>
          </xs:annotation>
        </xs:attribute>

      </xs:extension>
    </xs:complexContent>
  </xs:complexType>



  <xs:complexType name="ConditionalWhen">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ConditionalWhen</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="InputElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>



  <xs:complexType name="Repeat">
    <xs:annotation>
      <xs:documentation xml:lang="en">This is a container for any tag sets that can be contained within the 'inputs' tag set. When this is used, the tool will allow the user to add any number of additional sets of the contained parameters ( an "Add new 'title'" button will be displayed on the tool form ).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="InputType">
        <xs:sequence>
          <xs:group ref="InputElement" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="title" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"> The title of the repeat section, which will be displayed on the tool form </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="min" type="xs:integer">
          <xs:annotation>
            <xs:documentation xml:lang="en"> The minimum number of repeat units </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max" type="xs:integer">
          <xs:annotation>
            <xs:documentation xml:lang="en"> The maximum number of repeat units </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="default" type="xs:integer" default="1">
          <xs:annotation>
            <xs:documentation xml:lang="en"> The default number of repeat units </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="help" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Short help description for repeat element.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="Section">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        TODOWIKIMOVE
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="InputElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">The internal key used for the section</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="title" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Human readable label for the section</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expanded" type="PermissiveBoolean" default="false">
      <xs:annotation>
        <xs:documentation xml:lang="en">Whether the section should be expanded by default or not. If not, the default set values are used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Param">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for Param</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="InputType">
        <xs:sequence>
          <xs:group ref="ParamElement" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
        <!-- TODO: add unique constraints... -->
        <xs:attribute name="type" type="ParamType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for type</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="area" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for type</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="argument" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Command-line argument this parameter maps to (e.g. ``--foobar``).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="label" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for label</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="help" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for help</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="value" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for value</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="optional" type="xs:string" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for optional</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="min" type="xs:float">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for min</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max" type="xs:float">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for max</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="format" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for format</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="collection_type" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Restrict valid collection types for data_collection params (e.g. list, paired, list:paired, etc...).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="data_ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for data_ref</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="accept_default" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for accept_default</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="force_select" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for force_select</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="use_header_names" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for use_header_names</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="display" type="DisplayType">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for display</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="multiple" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for multiple</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="numerical" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for numerical</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="hierarchy" type="HierarchyType">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for hierarchy</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="checked" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for checked</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="truevalue" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for truevalue</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="falsevalue" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for falsevalue</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="size" type="xs:string">
          <!-- TODO: can be integer or integerxinteger -->
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for size</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="metadata_name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for metadata_name</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="dynamic_options" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Deprecated method to allow access to Python code to generate options for a select list.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:group name="ParamElement">
    <xs:choice>
      <xs:element name="label" type="xs:string">
        <xs:annotation>
          <xs:documentation xml:lang="en">Documentation for label</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="option" type="ParamOption" />
      <xs:element name="options" type="ParamOptions"/>
      <xs:element name="validator" type="Validator" />
      <xs:element name="sanitizer" type="Sanitizer"/>
      <xs:element name="help" type="xs:string">
        <xs:annotation>
          <xs:documentation xml:lang="en">Documentation for help</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>

  <xs:simpleType name="ParamType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ParamType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="text"/>
      <xs:enumeration value="integer"/>
      <xs:enumeration value="float"/>
      <xs:enumeration value="color"/>
      <xs:enumeration value="boolean"/>
      <xs:enumeration value="genomebuild"/>
      <xs:enumeration value="library_data"/>
      <xs:enumeration value="select"/>
      <xs:enumeration value="data_column"/>
      <xs:enumeration value="hidden"/>
      <xs:enumeration value="baseurl"/>
      <xs:enumeration value="file"/>
      <xs:enumeration value="data"/>
      <xs:enumeration value="drill_down"/>
      <xs:enumeration value="data_collection"/>
    </xs:restriction>
  </xs:simpleType>


  <xs:complexType name="Command">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
This tag specifies how Galaxy should invoke the tool's executable, passing its
required input parameter values (the command line specification links the
parameters supplied in the form with the actual tool executable). Any word
inside it starting with a dollar sign (``$``) will be treated as a variable whose
values can be acquired from one of three sources: parameters, metadata, or
output files. After the substitution of variables with their values, the content
is interpreted with [Cheetah](http://www.cheetahtemplate.org/) and finally given
to the interpreter specified in the corresponding attribute (if any).

### Examples

The following uses a compiled executable ([bedtools](http://bedtools.readthedocs.io/en/latest/)).

```xml
<command>bed12ToBed6 -i '$input' > '$output'</command>
```

A few things to note about even this simple example:

* Input and output variables (boringly named ``input`` and ``output``)
  are expanded into paths using the ``$`` Cheetah directive.
* Paths should be quoted so that the Galaxy database files may contain spaces.
* We are building up a shell script - so special characters like ``>`` can be used
  (in this case the standard output of the bedtools call is written to the path
  specified by ``'$output'``).

The bed12ToBed6 tool can be found [here](https://github.com/galaxyproject/tools-iuc/blob/master/tools/bedtools/bed12ToBed6.xml).

A more sophisticated bedtools example demonstrates the use of loops, conditionals,
and uses whitespace to make a complex command very readable can be found in
[annotateBed](https://github.com/galaxyproject/tools-iuc/blob/master/tools/bedtools/annotateBed.xml)
tool.

```xml
<command>
bedtools annotate
        -i "${inputA}"
        #if $names.names_select == 'yes':
            -files
            #for $bed in $names.beds:
                "${bed.input}"
            #end for
            -names
            #for $bed in $names.beds:
                "${bed.inputName}"
            #end for
        #else:
            #set files = '" "'.join( [ str( $file ) for $file in $names.beds ] )
            -files "${files}"
            #set names = '" "'.join( [ str( $name.display_name ) for $name in $names.beds ] )
            -names "${names}"
        #end if
        $strand
        $counts
        $both
        > "${output}"
</command>
```

The following example (taken from [xpath](https://github.com/galaxyproject/tools-iuc/blob/master/tools/xpath/xpath.xml) tool)
uses an interpreted executable. In this case a Perl script is shipped with the
tool and the directory of the tool itself is referenced with ``$__tool_directory__``.

```xml
<command>
  perl $__tool_directory__/xpath -q -e '$expression' '$input' > '$output'
</command>
```

The following example demonstrates accessing metadata from datasets. Metadata values
(e.g., ``${input.metadata.chromCol}``) are acquired from the ``Metadata`` model associated
with the objects selected as the values of each of the relative form field
parameters in the tool form. Accessing this information is generally enabled using
the following feature components.

A set of "metadata information" is defined for each supported data type (see the
``MetadataElement`` objects in the various data types classes in
[``/lib/galaxy/datatypes``](https://github.com/galaxyproject/galaxy/tree/dev/lib/galaxy/datatypes).
The ``DatasetFilenameWrapper`` class in the
[/lib/galaxy/tools/wrappers.py](https://github.com/galaxyproject/galaxy/blob/dev/lib/galaxy/tools/wrappers.py)
code file wraps a metadata collection to return metadata parameters wrapped
according to the Metadata spec.

```xml
<command>
        #set genome = $input.metadata.dbkey
        #set datatype = $input.datatype
        mkdir -p output_dir &amp;&amp;
        python $__tool_directory__/extract_genomic_dna.py
        --input "$input"
        --genome "$genome"
        #if $input.is_of_type("gff"):
            --input_format "gff"
            --columns "1,4,5,7"
            --interpret_features $interpret_features
        #else:
            --input_format "interval"
            --columns "${input.metadata.chromCol},${input.metadata.startCol},${input.metadata.endCol},${input.metadata.strandCol},${input.metadata.nameCol}"
        #end if
        --reference_genome_source $reference_genome_cond.reference_genome_source
        #if str($reference_genome_cond.reference_genome_source) == "cached"
            --reference_genome $reference_genome_cond.reference_genome.fields.path
        #else:
            --reference_genome $reference_genome_cond.reference_genome
        #end if
        --output_format $output_format_cond.output_format
        #if str($output_format_cond.output_format) == "fasta":
            --fasta_header_type $output_format_cond.fasta_header_type_cond.fasta_header_type
            #if str($output_format_cond.fasta_header_type_cond.fasta_header_type) == "char_delimited":
                --fasta_header_delimiter $output_format_cond.fasta_header_type_cond.fasta_header_delimiter
            #end if
        #end if
        --output $output
</command>
```

In additon to demonstrating accessing metadata, this example demonstrates:

* ``$input.is_of_type("gff")`` which can be used to check if an input is of a
  given datatype.
* ``#set datatype = $input.datatype`` which is the syntax for defining variables
  in Cheetah.

<a name="cheetah_reserved_variables"></a>

### Reserved Variables

Galaxy provides a few pre-defined variables which can be used in your command line,
even though they don't appear in your tool's parameters.

Name | Description
---- | -----------
``$__tool_directory__`` | The directory the tool currently resides in (new in 15.03)
``$__new_file_path__`` | ``config/galaxy.ini``'s ``new_file_path`` value
``$__tool_data_path__`` | ``config/galaxy.ini``'s tool_data_path value
``$__root_dir__`` | Top-level Galaxy source directory made absolute via ``os.path.abspath()``
``$__datatypes_config__`` | ``config/galaxy.ini``'s datatypes_config value
``$__user_id__`` | Email's numeric ID (id column of ``galaxy_user`` table in the database)
``$__user_email__`` | User's email address
``$__app__`` | The ``galaxy.app.UniverseApplication`` instance, gives access to all other configuration file variables (e.g. $__app__.config.output_size_limit). Should be used as a last resort, may go away in future releases.

Additional runtime properties are available as environment variables. Since these
are not Cheetah variables (the values aren't available until runtme) these should likely
be escaped with a backslash (``\``) when appearing in ``command`` or ``configfile`` elements.

Name | Description
---- | -----------
``\${GALAXY_SLOTS:-4}`` | Number of cores/threads allocated by the job runner or resource manager to the tool for the given job (here 4 is the default number of threads to use if running via custom runner that does not configure GALAXY_SLOTS or in an older Galaxy runtime).

See the [Planemo docs](http://planemo.readthedocs.io/en/latest/writing_advanced.html#cluster-usage)
on the topic of ``GALAXY_SLOTS`` for more information and examples.

### Attributes

#### ``detect_errors``

If present on the ``command`` tag, this attribute can be one of:

* ``default`` no-op fallback to ``stdio`` tags and erroring on standard error output (for legacy tools).
* ``exit_code`` error if tool exit code is not 0. (The @jmchilton recommendation).
* ``aggressive`` error if tool exit code is not 0 or either ``Exception:`` or ``Error:``
  appears in standard error/output. (The @bgruening recommendation).

For newer tools with ``profile>=16.04``, the default behavior is ``exit_code``.
Legacy tools default to ``default`` behavior described above (erroring if the tool
produces any standard error output).

See [PR 117](https://github.com/galaxyproject/galaxy/pull/117) for more implementation
information and discussion on the ``detect_errors`` attribute.

#### ``interpreter``

Older tools may define an ``intepreter`` attribute on the command, but this is
deprecated and using the ``$__tool_directory__`` variable is superior.
]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="detect_errors" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[
If present, this attribute can be one of

* ``default`` no-op fallback to ``stdio`` tags and erroring on standard error output (for legacy tools).
* ``exit_code`` error if tool exit code is not 0. (The @jmchilton recommendation).
* ``aggressive`` error if tool exit code is not 0 or either Exception: or Error: appears in standard error/output. (The @bgruening recommendation).

For newer tools with ``profile_version>=16.04``, the default is ``exit_code`` - legacy tools default to ``default`` described above.
]]>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="interpreter" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">This attribute defines the programming language in which the tool's executable file is written. Any language can be used (tools can be written in Python, C, Perl, Java, etc.). The executable file must be in the same directory of the XML file. If instead this attribute is not specified, the tag content should be a Bash command calling executable(s) available in the $PATH. </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strict" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>


  <xs:complexType name="ParamOption">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ParamOption</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="value" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for value</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="selected" type="PermissiveBoolean" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for selected</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>


  <xs:complexType name="ParamOptions">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for Options</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="OptionsElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="from_dataset" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for from_dataset</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="from_file" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for from_file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="from_data_table" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for from_data_table</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="from_parameter" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for from_parameter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="options_filter_attribute" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for options_filter_attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transform_lines" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for transform_lines</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startswith" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for startswith</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="OptionsElement">
    <xs:choice>
      <xs:element name="filter" type="Filter" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="column" type="Column" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="validator" type="Validator" minOccurs="0" maxOccurs="1"/>
      <xs:element name="file" type="xs:string" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation xml:lang="en">Documentation for file</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Column">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for Column</xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="index" type="xs:decimal" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for index</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Validator">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for Validator</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="type" type="ValidatorType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for type</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="message" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for message</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="check" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for check</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="filename" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for filename</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="metadata_name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for metadata_name</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="metadata_column" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">This can be an integer index to the column or a column name.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="line_startswith" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for line_startswith</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="min" type="xs:decimal">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for min</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max" type="xs:decimal">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for max</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="split" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for split</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skip" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for skip</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="table_name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for table_name</xs:documentation>
          </xs:annotation>
        </xs:attribute>

      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="Sanitizer">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
See ~/tools/filters/grep.xml for an example of how to use this tag set. This tag set is used to replace the basic parameter sanitization with custom directives. This tag set is contained within the <param> tag set - it contains a set of <valid> and <mapping> tags.

Examples:

```
<param name="mystring" type="text" label="Say something interesting">
  <sanitizer invalid_char="">
    <valid initial="string.letters,string.digits"><add value="_" /> </valid>
  </sanitizer>
</param>
```

```
<sanitizer>
  <valid initial="string.printable">
   <remove value="&apos;"/>
  </valid>
  <mapping initial="none">
    <add source="&apos;" target=""/>
  </mapping>
</sanitizer>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="SanitizerElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="sanitize" type="PermissiveBoolean" default="true">
      <xs:annotation>
        <xs:documentation xml:lang="en">is this parameter sanitized (default is ``true``)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="invalid_char" type="xs:string" default="X">
      <xs:annotation>
        <xs:documentation xml:lang="en">character to replace invalid characters with</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="SanitizerElement">
    <xs:choice>
      <xs:element name="valid" type="SanitizerValid"/>
      <xs:element name="mapping" type="SanitizerMapping"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="SanitizerValid">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Contained within the <sanitizer> tag set. Used to specify a list of allowed characters. Contains <add> and <remove> tags.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="SanitizerValidElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="initial" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">initial characters to allow
no, default is ``string.letters + string.digits + " -=_.()/+*^,:?!"``</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SanitizerValidAdd">
    <xs:annotation>
      <xs:documentation xml:lang="en">Used to add individual characters or preset lists of characters. Character must not be allowed as a valid input for the mapping to occur. Preset lists include default and none as well as those available from string.* (e.g. ``string.printable``).</xs:documentation>
    </xs:annotation>
    <xs:attribute name="preset" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Add target characters from the list of valid characters (e.g. ``string.printable``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Add a character to add to the list of valid characters</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SanitizerValidRemove">
    <xs:annotation>
      <xs:documentation xml:lang="en">Used to remove individual characters or preset lists of characters. Character must not be allowed as a valid input for the mapping to occur. Preset lists include default and none as well as those available from string.* (e.g. ``string.printable``).</xs:documentation>
    </xs:annotation>
    <xs:attribute name="preset" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Remove characters from the list of valid characters (e.g. ``string.printable``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">A character to remove from the list of valid characters</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="SanitizerValidElement">
    <xs:choice>
      <xs:element name="add" type="SanitizerValidAdd"/>
      <xs:element name="remove" type="SanitizerValidRemove"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="SanitizerMapping">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Contained within the <sanitizer> tag set. Used to specify a mapping of disallowed character to replacement string. Contains <add> and <remove> tags.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="SanitizerMappingElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="initial" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">initial character mapping (default is ``galaxy.util.mapped_chars``)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SanitizerMappingAdd">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Use to add character mapping during sanitization. Character must not be allowed as a valid input for the mapping to occur.]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Replace all occurrences of this character with the string of ``target``.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="target" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Replace all occurrences of ``source`` with this string</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SanitizerMappingRemove">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Use to remove character mapping during sanitization.]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Character to remove from mapping.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="SanitizerMappingElement">
    <xs:choice>
      <xs:element name="add" type="SanitizerMappingAdd" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="remove" type="SanitizerMappingRemove" minOccurs="0" maxOccurs="unbounded"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Filter">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for Filter</xs:documentation>
    </xs:annotation>
    <xs:attribute name="type" type="FilterType" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="column" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This can be a column index or a column name.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ref" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for ref</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="key" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="separator" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for separator</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compare" type="CompareType">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for compare</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keep" type="PermissiveBoolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for keep</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ref_attribute" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for ref_attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="index" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for index</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Outputs">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Container tag set for the <data> tag set. The files and collections created by tools as a result of their execution are named by Galaxy. You specify the number and type of your output files using the contained <data> and <collection> tags. You must pass them to your tool executable through using line variables just like the parameters described in the previous sections.
]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="OutputsElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="OutputsElement">
    <xs:choice>
      <xs:element name="data" type="Data"/>
      <xs:element name="collection" type="Collection" />
    </xs:choice>
  </xs:group>
  <xs:group name="DataElement">
    <xs:choice>
      <xs:element name="change_format" type="ChangeFormat"/>
      <xs:element name="filter" type="OutputFilter" />
      <xs:element name="discover_datasets" type="OutputDiscoverDatasets" />
      <xs:element name="actions" type="Actions"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Data">
    <xs:annotation>
      <xs:documentation xml:lang="en">TODOWIKIMOVE</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DataElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <!-- TODO: add a unique constraint for action. -->
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auto_format" type="PermissiveBoolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">If ``true``, this output will sniffed and its format determined automatically by Galaxy.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for format</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format_source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for format_source</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="metadata_source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for metadata_source</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="label" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for label</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="from_work_dir" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for from_work_dir</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hidden" type="xs:boolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for hidden</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:group name="CollectionElement">
    <xs:choice>
      <xs:element name="data" type="Data" />
      <xs:element name="discover_datasets" type="OutputCollectionDiscoverDatasets" />
      <xs:element name="filter" type="OutputFilter" />
    </xs:choice>
  </xs:group>

  <xs:complexType name="Collection">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for Collection</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="CollectionElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Collection type for output (e.g. ``paired``, ``list``, or ``list:list``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="label" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for label</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format_source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Input collection or dataset to derive output dataset element's format/datatype from.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type_source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Input collection to derive collection's type (e.g. ``collection_type``) from.</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="structured_like" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Input collection or dataset to derive structure of input from (out element count and identifiers).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inherit_format" type="xs:boolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">If ``structured_like`` is set, inherit format of outputs from format of corresponding input.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="OutputFilter">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
The ``<data>`` tag can contain a ``<filter>`` tag which includes a Python code block to be executed to test whether to include this output in the outputs the tool ultimately creates. If the code, when executed, returns ``True``, the output dataset is retained. In these code blocks the tool parameters appear as Python variables and are thus referred to without the $ used for the Cheetah template (used in the ``<command>`` tag). Variables that are part of conditionals are accessed using a hash named after the conditional. For example:

```xml
    <inputs>
      <param type="data" format="fasta" name="reference_genome" label="Reference genome" />
      <param type="data" format="bam" name="input_bam" label="Aligned reads" />
      <conditional name="options">
        <param label="Use advanced options" name="selection_mode" type="select">
          <option selected="True" value="defaults">Use default options</option>
          <option value="advanced">Use advanced options</option>
        </param>
        <when value="defaults"> </when>
        <when value="advanced">
          <param name="vcf_output" type="boolean" checked="false" label="VCF output"
            truevalue="--vcf" falsevalue="" />
        </when>
      <conditional>
    </inputs>
    <outputs>
      <data format="txt" label="Alignment report on ${on_string}" name="output_txt" />
      <data format="vcf" label="Variant summary on ${on_string}" name="output_vcf>
          <filter>options['selection_mode'] == 'advanced' and options['vcf_output']</filter>
      </data>
    </outputs>
    </outputs>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="OutputDiscoverDatasets">
     <xs:annotation>
      <xs:documentation xml:lang="en">Describe datasets to dynamically collect after the job complete.

More information can be found at https://wiki.galaxyproject.org/Admin/Tools/MultipleOutputFiles#Number_of_Output_datasets_cannot_be_determined_until_tool_run.
</xs:documentation>
    </xs:annotation>
    <xs:attribute name="pattern" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Regular expression used to find filenames and parse dynamic properties.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Directory (relative to working directory) to search for files.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Format (or datatype) of discovered datasets (an alias with ``ext``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ext" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Format (or datatype) of discovered datasets (an alias with ``format``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="visible" type="xs:boolean" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Indication if this dataset is visible in output history. This defaults to ``false``, but probably shouldn't - be sure to set to ``true`` if that is your intention.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="assign_primary_output" type="xs:boolean" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Replace the primary dataset described by the parameter ``data`` parameter with the first output discovered.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="OutputCollectionDiscoverDatasets">
     <xs:annotation>
      <xs:documentation xml:lang="en">See https://github.com/galaxyproject/galaxy/blob/master/test/functional/tools/collection_creates_dynamic_list_of_pairs.xml and https://github.com/galaxyproject/galaxy/blob/master/test/functional/tools/collection_creates_dynamic_nested.xml for examples</xs:documentation>
    </xs:annotation>
    <xs:attribute name="pattern" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Regular expression used to find filenames and parse dynamic properties.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Directory (relative to working directory) to search for files.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Format (or datatype) of discovered datasets (an alias with ``ext``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ext" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Format (or datatype) of discovered datasets (an alias with ``format``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="visible" type="xs:boolean" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Indication if this dataset is visible in output history. This defaults to ``false``, but probably shouldn't - be sure to set to ``true`` if that is your intention.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Actions">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[The ``<actions>`` in the Bowtie wrapper is used in lieu of the deprecated <code> tag to set the dbkey of the output dataset. In bowtie_wrapper.xml (see below), according to the first action block, if the refGenomeSource.genomeSource is "indexed" (not "history"), then it will assign the dbkey of the output file to be the same as that of the reference file. It does this by looking at through the loc file and finding the line that has the value that's been selected in the index dropdown box as column 1 of the loc file entry and using the dbkey, in column 0 (ignoring comment lines (starting with #) along the way).

If refGenomeSource.genomeSource is "history", it resorts to default behavior for Galaxy, which is that the output is assigned the same value as the first input that has a dbkey specified.

The second block would not be needed for most cases--it is required here to handle the specific case of a small reference file we use for functional testing. It says that if the dbkey has been set to "equCab2chrM" (that's what the <filter type="metadata_value"... column="1" /> tag) does then it should be changed to "equCab2" (the <option type="from_param" ... column="0" ...> tag does).

Example:

```xml
<actions>
   <conditional name="refGenomeSource.genomeSource">
      <when value="indexed">
           <action type="metadata" name="dbkey">
            <option type="from_file" name="bowtie_indices.loc" column="0" offset="0">
               <filter type="param_value" column="0" value="#" compare="startswith" keep="False"/>
               <filter type="param_value" ref="refGenomeSource.index" column="1"/>
            </option>
         </action>
       </when>
    </conditional>
    <!-- Special casing equCab2chrM to equCab2 -->
    <action type="metadata" name="dbkey">
        <option type="from_param" name="refGenomeSource.genomeSource" column="0" offset="0">
            <filter type="insert_column" column="0" value="equCab2chrM"/>
            <filter type="insert_column" column="0" value="equCab2"/>
            <filter type="metadata_value" ref="output" name="dbkey" column="1" />
        </option>
    </action>
</actions>
```

]]>
</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ActionsElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="ActionsElement">
    <xs:choice>
      <xs:element name="action" type="Action"/>
      <xs:element name="conditional" type="ActionsConditional"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Action">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="option" type="ActionsOption" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="type" type="ActionType">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="default" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ActionsOption">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="filter" type="Filter" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="type" type="ActionsOptionType">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="column" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="offset" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="param_attribute" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ActionsConditional">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="InputType">
        <xs:sequence>
          <xs:element name="when" type="ActionsConditionalWhen" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionsConditionalWhen">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="action" type="Action" minOccurs="1" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="EnvironmentVariables">
    <xs:annotation>
      <xs:documentation xml:lang="en">
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="environment_variable" type="EnvironmentVariable" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="EnvironmentVariable">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for name</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>


  <xs:complexType name="ConfigFiles">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[See ~/tools/maf/maf_filter.xml for an example of how this tag set is used in a tool. This tag set is a container for <configfile> tag sets - it defines an additional configuration section.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ConfigFilesElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:group name="ConfigFilesElement">
    <xs:choice>
      <xs:element name="inputs" type="ConfigInputs"/>
      <xs:element name="configfile" type="ConfigFile"/>
    </xs:choice>
  </xs:group>

  <xs:complexType name="ConfigFile">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
This tag set is contained within the <configfiles> tag set. It allows for the creation of a temporary file for file-based parameter transfer.

*Example*

The following is taken from the ~/tools/plotting/xy_plot.xml tool config.

```xml
<configfiles>
    <configfile name="script_file">
      ## Setup R error handling to go to stderr
      options( show.error.messages=F, error = function () { cat( geterrmessage(), file=stderr() ); q( "no", 1, F ) } )
      ## Determine range of all series in the plot
      xrange = c( NULL, NULL )
      yrange = c( NULL, NULL )
      #for $i, $s in enumerate( $series )
          s${i} = read.table( "${s.input.file_name}" )
          x${i} = s${i}[,${s.xcol}]
          y${i} = s${i}[,${s.ycol}]
          xrange = range( x${i}, xrange )
          yrange = range( y${i}, yrange )
      #end for
      ## Open output PDF file
      pdf( "${out_file1}" )
      ## Dummy plot for axis / labels
      plot( NULL, type="n", xlim=xrange, ylim=yrange, main="${main}", xlab="${xlab}", ylab="${ylab}" )
      ## Plot each series
      #for $i, $s in enumerate( $series )
          #if $s.series_type['type'] == "line"
              lines( x${i}, y${i}, lty=${s.series_type.lty}, lwd=${s.series_type.lwd}, col=${s.series_type.col} )
          #elif $s.series_type.type == "points"
              points( x${i}, y${i}, pch=${s.series_type.pch}, cex=${s.series_type.cex}, col=${s.series_type.col} )
          #end if
      #end for
      ## Close the PDF file
      devname = dev.off()
    </configfile>
</configfiles>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for name</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="ConfigInputs">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
This tag set is contained within the <configfiles> tag set. It tells Galaxy to write out a JSON representation of the tool parameters .

*Example*

The following will create a cheetah variable that can be evaluated as ``$inputs`` that
will contain the tool parameter inputs.

```xml
    <configfiles>
        <inputs name="inputs" />
    <configfiles>
```

The following will instead write the inputs to the tool's working directory with the specified name (i.e. ``inputs.json``).

```xml
    <configfiles>
        <inputs name="inputs" filename="inputs.json" />
    <configfiles>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Cheetah variable to populate the path to the inputs JSON file created in response to this directive.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="filename" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Path relative to the working directory of the tool for the inputs JSON file created in response to this directive.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="RequestParameterTranslation">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
        See ~/tools/data_source/ucsc_tablebrowser.xml for an example of how to use this tag set. This tag set is used only in "data_source" tools (the "tool_type" attribute value is "data_source"). This tag set is contained within the <param> tag set - it contains a set of <request_param> tags.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="request_param" minOccurs="0" maxOccurs="unbounded" type="RequestParameter"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="RequestParameter">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Contained within the <request_param_translation> tag set ( used only in "data_source" tools ) - the external data source application may send back parameter names like "GENOME" which must be translated to "dbkey" in Galaxy.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="RequestParameterElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="galaxy_name" type="RequestParameterGalaxyNameType">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          Each of these maps directly to a remote_name value
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remote_name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          The string representing the name of the parameter in the remote data source
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="missing" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          The default value to use for galaxy_name if the remote_name parameter is not included in the request
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="RequestParameterGalaxyNameType">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="URL" />
      <xs:enumeration value="dbkey" />
      <xs:enumeration value="organism" />
      <xs:enumeration value="table" />
      <xs:enumeration value="description" />
      <xs:enumeration value="name" />
      <xs:enumeration value="info" />
      <xs:enumeration value="data_type" />
    </xs:restriction>
  </xs:simpleType>

  <xs:group name="RequestParameterElement">
    <xs:choice>
      <xs:element name="append_param" type="RequestParameterAppend" />
      <xs:element name="value_translation" type="RequestParameterValueTranslation" />
    </xs:choice>
  </xs:group>

  <xs:complexType name="RequestParameterAppend">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Optionally contained within the <request_param> tag set if galaxy_name="URL" - some remote data sources ( e.g., Gbrowse, Biomart ) send parameters back to Galaxy in the initial response that must be added to the value of "URL" prior to Galaxy sending the secondary request to the remote data source via URL.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="value" minOccurs="0" maxOccurs="unbounded" type="RequestParameterAppendValue"/>
    </xs:sequence>
    <xs:attribute name="separator" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
The text to use to join the requested parameters together (example ``separator="&amp;"``).
        ]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="first_separator" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
The text to use to join the request_param parameters to the first requested parameter (example ``first_separator="?"``).
        ]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="join" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
The text to use to join the param name to its value (example ``join="="``).
        ]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="RequestParameterAppendValue">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Contained within the <append_param> tag set - allows for appending a param name / value pair to the value of URL.

Example:

```xml
<request_param_translation>
    <request_param galaxy_name="URL" remote_name="URL" missing="">
        <append_param separator="&amp;" first_separator="?" join="=">
            <value name="_export" missing="1" />
        </append_param>
    </request_param>
</request_param_tranlsation>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
Any valid HTTP request parameter name. The name / value pair must be received from the remote data source and will be appended to the value of URL as something like "&_export=1" (e.g. ``name="_export"``).
]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="missing" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[Must be a valid HTTP request parameter value (e.g. ``missing="1"``).]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="RequestParameterValueTranslation">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Optionally contained within the <request_param> tag set the parameter value received from a remote data source may be named differently in Galaxy, and this tag set allows for the value to be appropriately translated.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="value" minOccurs="0" maxOccurs="unbounded" type="RequestParameterValueTranslationValue"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="RequestParameterValueTranslationValue">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Contained within the <value_translation> tag set - allows for changing the data type value to something supported by Galaxy.

Example:

```xml
<request_param_translation>
    <request_param galaxy_name="data_type" remote_name="hgta_outputType" missing="bed" >
        <value_translation>
            <value galaxy_value="tabular" remote_value="primaryTable" />
        </value_translation>
    </request_param>
</request_param_tranlsation>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="galaxy_value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
The target value (e.g. for setting data format: the list of supported data formats is contained in the ~/config/datatypes_conf.xml.sample file).
]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remote_value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[The value supplied by the remote data source application]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Stdio">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Tools write the bulk of useful data to datasets, but they can also write messages to standard I/O (stdio) channels known as standard output (stdout) and standard error (stderr). Both stdout and stderr are typically written to the executing program's console or terminal. Previous versions of Galaxy checked stderr for execution errors - if any text showed up on stderr, then the tool's execution was marked as failed. However, many tools write messages to stderr that are not errors, and using stderr allows programs to redirect other interesting messages to a separate file. Programs may also exit with codes that indicate success or failure. One convention is for programs to return 0 on success and a non-zero exit code on failure.

Legacy tools (ones with ``profile_version`` unspecified or a ``profile_version`` of less than 16.04) will default to checking stderr for errors as described above. Newer tools will instead treat an exit code other than 0 as an error. The ``detect_error`` on ``command`` can swap between these behaviors but the ``stdio`` directive allows more options in defining error conditions (though these aren't always intuitive).

With ``stdio`` directive, Galaxy can use regular expressions to scan stdout and stderr, and it also allows exit codes to be scanned for ranges. The ``<stdio>`` tag has two subtags, ``<regex>`` and ``<exit_code>``, to define regular expressions and exit code processing, respectively. They are defined below. If a tool does not have any valid ``<regex>`` or ``<exit_code>`` tags, then Galaxy will use the previous technique for finding errors.

A note should be made on the order in which exit codes and regular expressions are applied and how the processing stops. Exit code rules are applied before regular expression rules. The rationale is that exit codes are more clearly defined and are easier to check computationally, so they are applied first. Exit code rules are applied in the order in which they appear in the tool's configuration file, and regular expressions are also applied in the order in which they appear in the tool's configuration file. However, once a rule is triggered that causes a fatal error, no further rules are checked.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="StdioElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:group name="StdioElement">
    <xs:choice>
      <xs:element name="regex" type="Regex"/>
      <xs:element name="exit_code" type="ExitCode"/>
    </xs:choice>
  </xs:group>

  <xs:complexType name="ExitCode">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Tools may use exit codes to indicate specific execution errors. Many programs use 0 to indicate success and non-zero exit codes to indicate errors. Galaxy allows each tool to specify exit codes that indicate errors. Each <exit_code> tag defines a range of exit codes, and each range can be associated with a description of the error (e.g., "Out of Memory", "Invalid Sequence File") and an error level. The description just describes the condition and can be anything. The error level is either a warning or a fatal error. A warning means that stderr will be updated with the error's description. A fatal error means that the tool's execution will be marked as having an error and the workflow will stop. Note that, if the error level is not supplied, then a fatal error is assumed to have occurred.

The exit code's range can be any consecutive group of integers. More advanced ranges, such as noncontiguous ranges, are currently not supported. Ranges can be specified in the form "m:n", where m is the start integer and n is the end integer. If ":n" is specified, then the exit code will be compared against all integers less than or equal to n. If "m:" is used, then the exit code will be compared against all integers greater than or equal to m. If the exit code matches, then the error level is applied and the error's description is added to stderr. If a tool's exit code does not match any of the supplied <exit_code> tags' ranges, then no errors are applied to the tool's execution.

Note that most Unix and Linux variants only support positive integers 0 to 255 for exit codes. If an exit code falls out of the range 0 to 255, the usual convention is to only use the lower 8 bits for the exit code. The only known exception is if a job is broken into subtasks using the tasks runner and one of those tasks is stopped with a POSIX signal. (Note that signals should be used as a last resort for terminating processes.) In those cases, the task will receive -1 times the signal number. For example, suppose that a job uses the tasks runner and 8 tasks are created for the job. If one of the tasks hangs, then a sysadmin may choose to send the "kill" signal, SIGKILL, to the process. In that case, the task (and its job) will exit with an exit code of -9. More on POSIX signals can be found at http://en.wikipedia.org/wiki/Unix_signal as well as man pages on "signal".

The <exit_code> tag's supported attributes are as follows:

* range: This indicates the range of exit codes to check. The range can be one of the following:
  * n: the exit code will only be compared to n;
  * [m:n]: the exit code must be greater than or equal to m and less than or equal to n;
  * [m:]: the exit code must be greater than or equal to m;
  * [:n]: the exit code must be less than or equal to n.
* level: This indicates the error level of the exit code. The level can have one of two values:
  * warning: If an exit code falls in the given range, then a description of the error will be added to the beginning of stderr. A warning-level error will not cause the tool to fail.
  * fatal: If an exit code falls in the given range, then a description of the error will be added to the beginning of stderr. A fatal-level error will cause the tool to fail. If no level is specified, then the fatal error level will be assumed to have occurred.
* description: This is an optional description of the error that corresponds to the exit code.
The following is an example of the <exit_code> tag:

```xml
<stdio>
    <exit_code range="2"   level="fatal"   description="Out of Memory" />
    <exit_code range="3:5" level="warning" description="Low disk space" />
    <exit_code range="6:"  level="fatal"   description="Bad input dataset" />
</stdio>
```

If the tool returns 0 or 1, then the tool will not be marked as having an error. If the exit code is 2, then the tool will fail with the description "Out of Memory" added to stderr. If the tool returns 3, 4, or 5, then the tool will not be marked as having failed, but "Low disk space" will be added to stderr. Finally, if the tool returns any number greater than or equal to 6, then the description "Bad input dataset" will be added to stderr and the tool will be marked as having failed.

]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="range" type="RangeType">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="level" type="LevelType">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>


  <xs:complexType name="Regex">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
A regular expression defines a pattern of characters. The patterns include the following:

GCTA, which matches on the fixed string "GCTA";
* [abcd], which matches on the characters a, b, c, or d;
* [CG]{12}, which matches on 12 consecutive characters that are C or G;
* a.*z, which matches on the character "a", followed by 0 or more characters of any type, followed by a "z";
* ^X, which matches the letter X at the beginning of a string;
* Y$, which matches the letter Y at the end of a string.

There are many more possible regular expressions. A reference to all supported regular expressions can be found under Python Regular Expression Syntax.

A regular expression includes the following attributes:

* source: This tells whether the regular expression should be matched against stdout, stderr, or both. If this attribute is missing or is incorrect, then both stdout and stderr will be checked. The source can be one of the follwing values:
  * stdout: the regular expression will be applied to stdout;
  * stderr: the regular expression will be applied to stderr;
  * both: the regular expression will be applied to both stderr and stdout (which is the default case).
* match: This is the regular expression that will be used to match against stdout and/or stderr. If the <regex> tag does not contain the match attribute, then the <regex> tag will be ignored. The regular expression can be any valid Python regular expression. All regular expressions are performed case insensitively. For example, if match contains the regular expression "actg", then the regular expression will match against "actg", "ACTG", "AcTg", and so on. Also note that, if double quotes (") are to be used in the match attribute, then the value " can be used in place of double quotes. Likewise, if single quotes (') are to be used in the match attribute, then the value ' can be used if necessary.
* level: This works very similarly to the <exit_code> tag, except that, when a regular expression matches against its source, the description is added to the beginning of the source. For example, if stdout matches on a regular expression, then the regular expression's description is added to the beginning of stdout (instead of stderr). The level can be log, warning or fatal as described below.
 * log and warning: If the regular expression matches against its source input (i.e., stdout and/or stderr), then a description of the error will be added to the beginning of the source, prepended with either 'Log:' or 'Warning:'. A log-level/warning-level error will not cause the tool to fail.
 * fatal: If the regular expression matches against its source input, then a description of the error will be added to the beginning of the source. A fatal-level error will cause the tool to fail. If no level is specified, then the fatal error level will be assumed to have occurred.
* description: Just like its <exit_code> counterpart, this is an optional description of the regular expression that has matched.

The following is an example of regular expressions that may be used:

```xml
<stdio>
    <regex match="low space"
           source="both"
           level="warning"
           description="Low space on device" />
    <regex match="error"
           source="stdout"
           level="fatal"
           description="Unknown error encountered" />
    <regex match="[CG]{12}"
           description="Fatal error - CG island 12 nts long found" />
    <regex match="^Branch A"
           level="warning"
           description="Branch A was taken in execution" />
</stdio>
```

The regular expression matching proceeds as follows. First, if either stdout or stderr match on "low space", then a warning is registered. If stdout contained the string "---LOW SPACE---", then stdout has the string "Warning: Low space on device" added to its beginning. The same goes for if stderr had contained the string "low space". Since only a warning could have occurred, the processing continues.

Next, the regular expression "error" is matched only against stdout. If stdout contains the string "error" regardless of its capitalization, then a fatal error has occurred and the processing stops. In that case, stdout would be prepended with the string "Fatal: Unknown error encountered". Note that, if stderr contained "error", "ERROR", or "ErRor" then it would not matter - stderr was not being scanned.

If the second regular expression did not match, then the third regular expression is checked. The third regular expression does not contain an error level, so an error level of "fatal" is assumed. The third regular expression also does not contain a source, so both stdout and stderr are checked. The third regular expression looks for 12 consecutive "C"s or "G"s in any order and in uppercase or lowercase. If stdout contained "cgccGGCCcGGcG" or stderr contained "CCCCCCgggGGG", then the regular expression would match, the tool would be marked with a fatal error, and the stream that contained the 12-nucleotide CG island would be prepended with "Fatal: Fatal error - CG island 12 nts long found".

Finally, if the tool did not match any of the fatal errors, then the fourth regular expression is checked. Since no source is specified, both stdout and stderr are checked. If "Branch A" is at the beginning of stdout or stderr, then a warning will be registered and the source that contained "Branch A" will be prepended with the warning "Warning: Branch A was taken in execution".
]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="source" type="SourceType">
      <xs:annotation>
        <xs:documentation xml:lang="en">This tells whether the regular expression should be matched against stdout, stderr, or both. If this attribute is missing or is incorrect, then both stdout and stderr will be checked. The source can be one of the follwing values: </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="match" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This is the regular expression that will be used to match against stdout and/or stderr. </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="level" type="LevelType">
      <xs:annotation>
        <xs:documentation xml:lang="en">This works very similarly to the 'exit_code' tag, except that, when a regular expression matches against its source, the description is added to the beginning of the source.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">an optional description of the regular expression that has matched.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="ChangeFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[See ~/tools/extract/extract_genomic_dna.xml for an example of how this tag set is used in a tool. This tag set is optionally contained within the <data> tag set and is the container tag set for the following <when> tag set.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="when" type="ChangeFormatWhen" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ChangeFormatWhen">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
If the data type of the output dataset is the specified type, the data type is changed to the desired type.

Examples:

Assume that your tool config includes the following select list parameter structure:


```xml
<param name="out_format" type="select" label="Output data type">
    <option value="fasta">FASTA</option>
    <option value="interval">Interval</option>
</param>
```

Then whenever the user selects the "interval"" option from the select list, the following structure in your tool config will override the format="fasta" setting in the <data> tag set with format="interval".

```xml
<outputs>
    <data format="fasta" name="out_file1">
        <change_format>
            <when input="out_format" value="interval" format="interval" />
        </change_format>
    </data>
</outputs>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:sequence/>
    <xs:attribute name="input" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must be the attribute name of the desired input parameter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must also be an attribute name of an input parameter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must be a supported data type (e.g. ``format="interval"``)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Citations">
    <xs:annotation>
      <xs:documentation xml:lang="en">Tool files may declare one citations element. Each citations element can contain one or more citation tag elements - each of which specifies tool citation information using either a DOI or a BibTeX entry.
</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="citation" type="Citation" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="Citation">
    <xs:annotation>
      <xs:documentation xml:lang="en">Each citations element can contain one or more citation tag elements - each of which specifies tool citation information using either a DOI or a BibTeX entry.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="type" type="CitationType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">type of citation</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:simpleType name="CitationType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Type of citation represented.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="bibtex"/>
      <xs:enumeration value="doi"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="RequirementType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for RequirementType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="python-module"/>
      <xs:enumeration value="binary"/>
      <xs:enumeration value="package"/>
      <xs:enumeration value="set_environment"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ContainerType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Type of container for tool execution.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="docker"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ToolTypeType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ToolTypeType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="data_source"/>
      <xs:enumeration value="manage_data"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="URLmethodType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for URLmethodType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="get"/>
      <xs:enumeration value="post"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TargetType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for TargetType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="_top"/>
      <xs:enumeration value="_parent"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MethodType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for MethodType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="basic"/>
      <xs:enumeration value="multi"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DisplayType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for DisplayType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="checkboxes"/>
      <xs:enumeration value="radio"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HierarchyType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for HierarchyType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="exact"/>
      <xs:enumeration value="recurse"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ValidatorType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ValidatorType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="empty_dataset"/>
      <xs:enumeration value="expression"/>
      <xs:enumeration value="regex"/>
      <xs:enumeration value="in_range"/>
      <xs:enumeration value="length"/>
      <xs:enumeration value="metadata"/>
      <xs:enumeration value="unspecified_build"/>
      <xs:enumeration value="no_options"/>
      <xs:enumeration value="empty_field"/>
      <xs:enumeration value="dataset_metadata_in_file"/>
      <xs:enumeration value="dataset_metadata_in_data_table"/>
      <xs:enumeration value="dataset_ok_validator"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="FilterType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for FilterType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="data_meta"/>
      <xs:enumeration value="param_value"/>
      <xs:enumeration value="static_value"/>
      <xs:enumeration value="unique_value"/>
      <xs:enumeration value="multiple_splitter"/>
      <xs:enumeration value="add_value"/>
      <xs:enumeration value="sort_by"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ActionType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ActionType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="format"/>
      <xs:enumeration value="metadata"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ActionsOptionType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ActionsOptionType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="from_data_table"/>
      <xs:enumeration value="from_param"/>
      <xs:enumeration value="from_file"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CompareType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for CompareType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="startswith"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="LevelType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for LevelType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="fatal"/>
      <xs:enumeration value="warning"/>
      <xs:enumeration value="log"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="RangeType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for RangeType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value="\-?(\d)*:?\-?(\d)*"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SourceType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for SourceType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="stdout"/>
      <xs:enumeration value="stderr"/>
      <xs:enumeration value="both"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TestOutputCompareType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Type of comparison to use for test outputs.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="diff"/>
      <xs:enumeration value="re_match"/>
      <xs:enumeration value="sim_size"/>
      <xs:enumeration value="re_match_multiline"/>
      <xs:enumeration value="contains"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="PermissiveBoolean">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for PermissiveBoolean</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="0"/>
      <xs:enumeration value="1"/>
      <xs:enumeration value="true"/>
      <xs:enumeration value="false"/>
      <xs:enumeration value="True"/>
      <xs:enumeration value="False"/>
      <xs:enumeration value="yes"/>
      <xs:enumeration value="no"/>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>
