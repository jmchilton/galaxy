{"version":3,"sources":["mvc/history/history-model.js"],"names":["History","Backbone","Model","extend","_baseMvc2","default","LoggableMixin","mixin","SearchableModelMixin","_logNamespace","UPDATE_DELAY","defaults","model_class","id","name","state","deleted","contents_active","urlRoot","Galaxy","root","_historyContents2","HistoryContents","tag","contentsClass","historyJSON","options","this","logger","searchAttributes","searchAliases","history","historyId","get","order","_setUpListeners","_setUpCollectionListeners","initialize","updateTimeoutId","on","clearUpdateTimeout","model","newId","contents","error","trigger","apply","arguments","contentsShown","contentsActive","active","shown","includeDeleted","includeHidden","hidden","nice_size","size","_utils2","bytesToString","_localization2","toJSON","_","prototype","call","key","user","isAnonymous","numOfUnfinishedJobs","unfinishedJobIds","length","numOfUnfinishedShownContents","runningAndActive","_fetchContentRelatedAttributes","contentRelatedAttrs","fetch","data","$","param","keys","join","refresh","_this","lastUpdateTime","currentPage","fetchUpdated","done","response","status","xhr","serverResponseDatetime","Date","getResponseHeader","err","checkForUpdates","_this2","fetchFn","delay","_delayThenUpdate","historyData","nonReadyContentCount","stopPolling","parse","parsed","create_time","update_time","contentsOptions","self","view","setHistoryId","fetchContents","fetchCurrentPage","jQuery","when","purge","save","undelete","copy","current","allDatasets","undefined","postData","history_id","all_datasets","post","setAsCurrent","getJSON","_collectionSuper","_controlledFetchCollection2","InfinitelyScrollingCollection","HistoryCollection","limitOnFirstFetch","limitPerFetch","models","log","currentHistoryId","change:deleted","debug","remove","copied","original","newData","setCurrent","set-as-current","oldCurrentId","_buildFetchData","_buildFetchFilters","superFilters","filters","purged","fetchFirst","limit","encoded_id-in","then","offset","fetchMore","silent","name-dsc","buildComparator","ascending","size-asc","sort","comparators","clone","create","hdas","historyOptions","collection","unshift"],"mappings":"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","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["import HISTORY_CONTENTS from \"mvc/history/history-contents\";\nimport HISTORY_PREFS from \"mvc/history/history-preferences\";\nimport CONTROLLED_FETCH_COLLECTION from \"mvc/base/controlled-fetch-collection\";\nimport UTILS from \"utils/utils\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport _l from \"utils/localization\";\n\n//==============================================================================\n/** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\nvar History = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n    BASE_MVC.mixin(\n        BASE_MVC.SearchableModelMixin,\n        /** @lends History.prototype */ {\n            _logNamespace: \"history\",\n\n            /** ms between fetches when checking running jobs/datasets for updates */\n            UPDATE_DELAY: 4000,\n\n            // values from api (may need more)\n            defaults: {\n                model_class: \"History\",\n                id: null,\n                name: \"Unnamed History\",\n                state: \"new\",\n\n                deleted: false,\n                contents_active: {},\n                contents_states: {}\n            },\n\n            urlRoot: `${Galaxy.root}api/histories`,\n\n            contentsClass: HISTORY_CONTENTS.HistoryContents,\n\n            /** What model fields to search with */\n            searchAttributes: [\"name\", \"annotation\", \"tags\"],\n\n            /** Adding title and singular tag */\n            searchAliases: {\n                title: \"name\",\n                tag: \"tags\"\n            },\n\n            // ........................................................................ set up/tear down\n            /** Set up the model\n             *  @param {Object} historyJSON model data for this History\n             *  @param {Object} options     any extra settings including logger\n             */\n            initialize: function(historyJSON, options) {\n                options = options || {};\n                this.logger = options.logger || null;\n                this.log(`${this}.initialize:`, historyJSON, options);\n\n                /** HistoryContents collection of the HDAs contained in this history. */\n                this.contents = new this.contentsClass([], {\n                    history: this,\n                    historyId: this.get(\"id\"),\n                    order: options.order\n                });\n\n                this._setUpListeners();\n                this._setUpCollectionListeners();\n\n                /** cached timeout id for the dataset updater */\n                this.updateTimeoutId = null;\n            },\n\n            /** set up any event listeners for this history including those to the contained HDAs\n             *  events: error:contents  if an error occurred with the contents collection\n             */\n            _setUpListeners: function() {\n                // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n                return this.on({\n                    error: function(model, xhr, options, msg, details) {\n                        this.clearUpdateTimeout();\n                    },\n                    \"change:id\": function(model, newId) {\n                        if (this.contents) {\n                            this.contents.historyId = newId;\n                        }\n                    }\n                });\n            },\n\n            /** event handlers for the contents submodels */\n            _setUpCollectionListeners: function() {\n                if (!this.contents) {\n                    return this;\n                }\n                // bubble up errors\n                return this.listenTo(this.contents, {\n                    error: function() {\n                        this.trigger.apply(this, jQuery.makeArray(arguments));\n                    }\n                });\n            },\n\n            // ........................................................................ derived attributes\n            /**  */\n            contentsShown: function() {\n                var contentsActive = this.get(\"contents_active\");\n                var shown = contentsActive.active || 0;\n                shown += this.contents.includeDeleted ? contentsActive.deleted : 0;\n                shown += this.contents.includeHidden ? contentsActive.hidden : 0;\n                return shown;\n            },\n\n            /** convert size in bytes to a more human readable version */\n            nice_size: function() {\n                var size = this.get(\"size\");\n                return size ? UTILS.bytesToString(size, true, 2) : _l(\"(empty)\");\n            },\n\n            /** override to add nice_size */\n            toJSON: function() {\n                return _.extend(Backbone.Model.prototype.toJSON.call(this), {\n                    nice_size: this.nice_size()\n                });\n            },\n\n            /** override to allow getting nice_size */\n            get: function(key) {\n                if (key === \"nice_size\") {\n                    return this.nice_size();\n                }\n                return Backbone.Model.prototype.get.apply(this, arguments);\n            },\n\n            // ........................................................................ common queries\n            /** T/F is this history owned by the current user (Galaxy.user)\n             *      Note: that this will return false for an anon user even if the history is theirs.\n             */\n            ownedByCurrUser: function() {\n                // no currUser\n                if (!Galaxy || !Galaxy.user) {\n                    return false;\n                }\n                // user is anon or history isn't owned\n                if (Galaxy.user.isAnonymous() || Galaxy.user.id !== this.get(\"user_id\")) {\n                    return false;\n                }\n                return true;\n            },\n\n            /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n            numOfUnfinishedJobs: function() {\n                var unfinishedJobIds = this.get(\"non_ready_jobs\");\n                return unfinishedJobIds ? unfinishedJobIds.length : 0;\n            },\n\n            /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n            numOfUnfinishedShownContents: function() {\n                return this.contents.runningAndActive().length || 0;\n            },\n\n            // ........................................................................ updates\n            _fetchContentRelatedAttributes: function() {\n                var contentRelatedAttrs = [\"size\", \"non_ready_jobs\", \"contents_active\", \"hid_counter\"];\n                return this.fetch({\n                    data: $.param({\n                        keys: contentRelatedAttrs.join(\",\")\n                    })\n                });\n            },\n\n            /** check for any changes since the last time we updated (or fetch all if ) */\n            refresh: function(options) {\n                // console.log( this + '.refresh' );\n                options = options || {};\n\n                // note if there was no previous update time, all summary contents will be fetched\n                var lastUpdateTime = this.lastUpdateTime;\n                // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n                this.contents.allFetched = false;\n                var fetchFn =\n                    this.contents.currentPage !== 0\n                        ? () => this.contents.fetchPage(this.contents.currentPage)\n                        : () => this.contents.fetchUpdated(lastUpdateTime);\n                // note: if there was no previous update time, all summary contents will be fetched\n                return fetchFn().done((response, status, xhr) => {\n                    var serverResponseDatetime;\n                    try {\n                        serverResponseDatetime = new Date(xhr.getResponseHeader(\"Date\"));\n                    } catch (err) {}\n                    this.lastUpdateTime = serverResponseDatetime || new Date();\n                    this.checkForUpdates(options);\n                });\n            },\n\n            /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n            checkForUpdates: function(options) {\n                // console.log( this + '.checkForUpdates' );\n                options = options || {};\n                var delay = this.UPDATE_DELAY;\n                if (!this.id) {\n                    return;\n                }\n\n                var _delayThenUpdate = () => {\n                    // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n                    this.clearUpdateTimeout();\n                    this.updateTimeoutId = setTimeout(() => {\n                        this.refresh(options);\n                    }, delay);\n                };\n\n                // if there are still datasets in the non-ready state, recurse into this function with the new time\n                var nonReadyContentCount = this.numOfUnfinishedShownContents();\n                // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n                if (nonReadyContentCount > 0) {\n                    _delayThenUpdate();\n                } else {\n                    // no datasets are running, but currently runnning jobs may still produce new datasets\n                    // see if the history has any running jobs and continue to update if so\n                    // (also update the size for the user in either case)\n                    this._fetchContentRelatedAttributes().done(historyData => {\n                        // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                        if (this.numOfUnfinishedJobs() > 0) {\n                            _delayThenUpdate();\n                        } else {\n                            // otherwise, let listeners know that all updates have stopped\n                            this.trigger(\"ready\");\n                        }\n                    });\n                }\n            },\n\n            /** clear the timeout and the cached timeout id */\n            clearUpdateTimeout: function() {\n                if (this.updateTimeoutId) {\n                    clearTimeout(this.updateTimeoutId);\n                    this.updateTimeoutId = null;\n                }\n            },\n\n            stopPolling: function() {\n                this.clearUpdateTimeout();\n                if (this.contents) {\n                    this.contents.stopPolling();\n                }\n            },\n\n            // ........................................................................ ajax\n            /** override to use actual Dates objects for create/update times */\n            parse: function(response, options) {\n                var parsed = Backbone.Model.prototype.parse.call(this, response, options);\n                if (parsed.create_time) {\n                    parsed.create_time = new Date(parsed.create_time);\n                }\n                if (parsed.update_time) {\n                    parsed.update_time = new Date(parsed.update_time);\n                }\n                return parsed;\n            },\n\n            /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n            fetchWithContents: function(options, contentsOptions) {\n                options = options || {};\n                var self = this;\n\n                // console.log( this + '.fetchWithContents' );\n                // TODO: push down to a base class\n                options.view = \"dev-detailed\";\n\n                // fetch history then use history data to fetch (paginated) contents\n                return this.fetch(options).then(function getContents(history) {\n                    self.contents.history = self;\n                    self.contents.setHistoryId(history.id);\n                    return self.fetchContents(contentsOptions);\n                });\n            },\n\n            /** fetch this histories contents, adjusting options based on the stored history preferences */\n            fetchContents: function(options) {\n                options = options || {};\n                var self = this;\n\n                // we're updating, reset the update time\n                self.lastUpdateTime = new Date();\n                return self.contents.fetchCurrentPage(options);\n            },\n\n            /** save this history, _Mark_ing it as deleted (just a flag) */\n            _delete: function(options) {\n                if (this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true }, options);\n            },\n            /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n            purge: function(options) {\n                if (this.get(\"purged\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true, purged: true }, options);\n            },\n            /** save this history, _Mark_ing it as undeleted */\n            undelete: function(options) {\n                if (!this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: false }, options);\n            },\n\n            /** Make a copy of this history on the server\n             *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n             *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n             *  @fires copied               passed this history and the response JSON from the copy\n             *  @returns {xhr}\n             */\n            copy: function(current, name, allDatasets) {\n                current = current !== undefined ? current : true;\n                if (!this.id) {\n                    throw new Error(\"You must set the history ID before copying it.\");\n                }\n\n                var postData = { history_id: this.id };\n                if (current) {\n                    postData.current = true;\n                }\n                if (name) {\n                    postData.name = name;\n                }\n                if (!allDatasets) {\n                    postData.all_datasets = false;\n                }\n                postData.view = \"dev-detailed\";\n\n                var history = this;\n                var copy = jQuery.post(this.urlRoot, postData);\n                // if current - queue to setAsCurrent before firing 'copied'\n                if (current) {\n                    return copy.then(response => {\n                        var newHistory = new History(response);\n                        return newHistory.setAsCurrent().done(() => {\n                            history.trigger(\"copied\", history, response);\n                        });\n                    });\n                }\n                return copy.done(response => {\n                    history.trigger(\"copied\", history, response);\n                });\n            },\n\n            setAsCurrent: function() {\n                var history = this;\n\n                var xhr = jQuery.getJSON(`${Galaxy.root}history/set_as_current?id=${this.id}`);\n\n                xhr.done(() => {\n                    history.trigger(\"set-as-current\", history);\n                });\n                return xhr;\n            },\n\n            // ........................................................................ misc\n            toString: function() {\n                return `History(${this.get(\"id\")},${this.get(\"name\")})`;\n            }\n        }\n    )\n);\n\n//==============================================================================\nvar _collectionSuper = CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n/** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\nvar HistoryCollection = _collectionSuper.extend(BASE_MVC.LoggableMixin).extend({\n    _logNamespace: \"history\",\n\n    model: History,\n    /** @type {String} initial order used by collection */\n    order: \"update_time\",\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch: 10,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch: 10,\n\n    initialize: function(models, options) {\n        options = options || {};\n        this.log(\"HistoryCollection.initialize\", models, options);\n        _collectionSuper.prototype.initialize.call(this, models, options);\n\n        /** @type {boolean} should deleted histories be included */\n        this.includeDeleted = options.includeDeleted || false;\n\n        /** @type {String} encoded id of the history that's current */\n        this.currentHistoryId = options.currentHistoryId;\n\n        this.setUpListeners();\n        // note: models are sent to reset *after* this fn ends; up to this point\n        // the collection *is empty*\n    },\n\n    urlRoot: `${Galaxy.root}api/histories`,\n    url: function() {\n        return this.urlRoot;\n    },\n\n    /** set up reflexive event handlers */\n    setUpListeners: function setUpListeners() {\n        return this.on({\n            // when a history is deleted, remove it from the collection (if optionally set to do so)\n            \"change:deleted\": function(history) {\n                // TODO: this becomes complicated when more filters are used\n                this.debug(\"change:deleted\", this.includeDeleted, history.get(\"deleted\"));\n                if (!this.includeDeleted && history.get(\"deleted\")) {\n                    this.remove(history);\n                }\n            },\n            // listen for a history copy, setting it to current\n            copied: function(original, newData) {\n                this.setCurrent(new History(newData, []));\n            },\n            // when a history is made current, track the id in the collection\n            \"set-as-current\": function(history) {\n                var oldCurrentId = this.currentHistoryId;\n                this.trigger(\"no-longer-current\", oldCurrentId);\n                this.currentHistoryId = history.id;\n            }\n        });\n    },\n\n    /** override to change view */\n    _buildFetchData: function(options) {\n        return _.extend(_collectionSuper.prototype._buildFetchData.call(this, options), {\n            view: \"dev-detailed\"\n        });\n    },\n\n    /** override to filter out deleted and purged */\n    _buildFetchFilters: function(options) {\n        var superFilters = _collectionSuper.prototype._buildFetchFilters.call(this, options) || {};\n        var filters = {};\n        if (!this.includeDeleted) {\n            filters.deleted = false;\n            filters.purged = false;\n        } else {\n            // force API to return both deleted and non\n            //TODO: when the API is updated, remove this\n            filters.deleted = null;\n        }\n        return _.defaults(superFilters, filters);\n    },\n\n    /** override to fetch current as well (as it may be outside the first 10, etc.) */\n    fetchFirst: function(options) {\n        var self = this;\n        // TODO: batch?\n        var xhr = $.when();\n        if (this.currentHistoryId) {\n            xhr = _collectionSuper.prototype.fetchFirst.call(self, {\n                silent: true,\n                limit: 1,\n                filters: {\n                    // without these a deleted current history will return [] here and block the other xhr\n                    purged: \"\",\n                    deleted: \"\",\n                    \"encoded_id-in\": this.currentHistoryId\n                }\n            });\n        }\n        return xhr.then(() => {\n            options = options || {};\n            options.offset = 0;\n            return self.fetchMore(options);\n        });\n    },\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators: _.extend(_.clone(_collectionSuper.prototype.comparators), {\n        name: BASE_MVC.buildComparator(\"name\", {\n            ascending: true\n        }),\n        \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n            ascending: false\n        }),\n        size: BASE_MVC.buildComparator(\"size\", {\n            ascending: false\n        }),\n        \"size-asc\": BASE_MVC.buildComparator(\"size\", {\n            ascending: true\n        })\n    }),\n\n    /** override to always have the current history first */\n    sort: function(options) {\n        options = options || {};\n        var silent = options.silent;\n        var currentHistory = this.remove(this.get(this.currentHistoryId));\n        _collectionSuper.prototype.sort.call(this, _.defaults({ silent: true }, options));\n        this.unshift(currentHistory, { silent: true });\n        if (!silent) {\n            this.trigger(\"sort\", this, options);\n        }\n        return this;\n    },\n\n    /** create a new history and by default set it to be the current history */\n    create: function create(data, hdas, historyOptions, xhrOptions) {\n        //TODO: .create is actually a collection function that's overridden here\n        var collection = this;\n\n        var xhr = jQuery.getJSON(`${Galaxy.root}history/create_new_current`);\n        return xhr.done(newData => {\n            collection.setCurrent(new History(newData, [], historyOptions || {}));\n        });\n    },\n\n    /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n    setCurrent: function(history, options) {\n        options = options || {};\n        // new histories go in the front\n        this.unshift(history, options);\n        this.currentHistoryId = history.get(\"id\");\n        if (!options.silent) {\n            this.trigger(\"new-current\", history, this);\n        }\n        return this;\n    },\n\n    toString: function toString() {\n        return `HistoryCollection(${this.length},current:${this.currentHistoryId})`;\n    }\n});\n\n//==============================================================================\nexport default {\n    History: History,\n    HistoryCollection: HistoryCollection\n};\n"]}